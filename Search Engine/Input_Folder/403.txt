https://medium.com/swlh/a-guide-to-python-virtual-environments-8af34aa106ac
Venv Envy (A Guide to Python Virtual Environments) - The Startup - Medium Sign in Top Story Medium Tips Submit Venv Envy (A Guide to Python Virtual Environments) Lora Johns Follow Nov 19, 2019 · 17 min read Setup nearly-painless virtual Python installations with pyenv, pyenv-virtualenv, and Homebrew. Table of Contents Preface: the $PATH to enlightenment Step 0: Clean up your Superfund Site Step 1: Get to know your shell profile Step 2: Install pyenv with Homebrew Step 3: Configure pyenv Interlude: A primer on PATH and profiles (back to setup) Step 4: Configure pyenv-virtualenv Step 5: Download Python versions Step 6: Make virtual environments! Step 7: Activate your virtual environment (with GitHub gist) Step 8: Whatever you want! Help and More Info pyenv documentation installation problems virtual environment problems uninstall pyenv, pyenv-virtualenv, and Homebrew what’s next How much do you know about your Python installation? Go to your command line and type in whence python (or command -v python). If that file path surprises you, give yourself 1 point. Type in which -a python. If you get 2–3 results, and none of them are symlinks, give yourself 1 point. If you get more than 3 results, give yourself 2 points. If you use conda, locate your conda configuration file. If you don’t know where it is, give yourself 2 points. If you can find it but you’re surprised to see what’s in it, give yourself 1. Find your virtual environments folder(s). If you can’t, or they don’t exist, give yourself 2 points. If they’re empty, or sparse, give yourself 1. Open your bash/zsh profile or equivalent. If that sentence doesn’t make sense to you, give yourself 2 points. If your PATH variable looks like someone mashed your keyboard, give yourself 1. If you don’t generally create a virtual environment or container for each new project, give yourself 1 point. How’d you do? 0–3 points: You know your way around your system, and can probably diagnose most of your Python environment problems. Setting up the virtual environment workflow outlined in this article ought to be a breeze. 4–7 points: You probably have some junk in your Python environment. A more deliberate approach to virtual environments could save you some frustration. 7–10 points: Many of the irritations you probably experience with pip and conda will go away if you learn a bit more about how your computer sees Python packages. You’ll learn how to handle conflicting requirements in different projects without muddying up your base environment. Why do I need virtual environments, though? If you’ve been using Python for any length of time, you’ve had the frustration of a cluttered development environment with too many packages installed. You don’t need them all at one time, and trying to figure out which ones are necessary for your project is frustrating to do by hand. You certainly don’t need or want to update them all at the same time, if ever. In fact, some software may depend on older versions of a package, and updating to a newer one would break its functionality. But a different program of yours may require a newer version. It’s extremely difficult to manage these conflicts manually. Virtual environments also aid reproducibility in data science. If you provide the exact versions of the libraries that you used in your scientific analysis, your results will be more verifiable. In fact, this dependency management can play a vital role in accountability and accuracy. What’s a venv and why should I care? Virtual environments (venvs) are just directories that contain a set of instructions telling your computer how to handle a Python project. They contain files that let you interact with the venv, headers to compile packages, and a copy of the Python version you want to use. Virtual environments are, essentially, path hijackers. Your PATH environment variable tells your operating system which directories it should look in to find executables. When you activate a venv, you’re temporarily rerouting your PATH so that executables can only “see” the interpreter, packages, and symlinks to tools that reside inside of the venv’s directory. You can verify that venvs change your PATH by running inside a virtual environment, and then again outside of one. By changing your PATH while it’s activated, a virtual environment allows you to create parallel silos within which contradictory Python environments can coexist. It’s a brilliantly simple idea with a convoluted execution. Why does Python mess this up so badly? Python has a fantastic open source community, but that also means a proliferation of tools and methods for everything. You can, for example, download Python: via a binary installer by downloading Anaconda using Homebrew by chanting “Python” in front of a mirror and end up with installations in different places (not to mention your system Python, which you should never touch). Packages don’t always get upgraded at the same time, and many are not compatible with each other or even with the version of Python or Anaconda that you’re running. Packages from the different channels within conda aren’t even guaranteed not to conflict. If you’re downloading everything into the same big environment, it’s inevitable that you’ll end up with inconsistent dependencies, and things will break. this is not wise. Not to mention the various tools like pip, pipx, conda, poetry, hatch, pipenv, pyenv, virtualenv, pyvenv, pyenv-virtualenv, virtualenvwrapper, pyenv-virtualenvwrapper, and venv… which, despite sounding very much alike, often aren’t even compatible with each other. Further reason not to use anaconda outside of a container — you don’t know what you’re running .In some bizarre cases, anaconda’s activation script so badly mangles the system’s environment pre-pyenv cleanup that the only quick way to fix the problem is to prepend HOST=$(hostname) to the .zshrc. I feel confident running this code in my user root directory, don’t you? Furthermore, your venvs may live in lots of different directories, depending on which tools you’re using (or not using). That gets unwieldy pretty fast. Heaven help you if you want to have a clean R installation, too, let alone one that works well with reticulate. And good luck making sure you have the right IPython kernels set up for your Jupyter notebooks. What happens when you screw it up? Ranging from “mildly annoying” to “catastrophically terrible”: You can’t import packages and don’t know why. It’s very irritating, and you spend a long time Googling the issue to no avail. The interpreter for Jupyter/R Studio/Spyder/etc. can’t find the right version of R or Python that you want to use, because your path variable is very confused. It takes you a while to clean it up and you forget what you wanted to analyze in the first place. You can’t conda install something, so you pip install it instead, but end up with error messages that say something’s broken in a file you don’t recognize. You spend too much time on StackOverflow and get a headache reading the source code of some library on GitHub. (I’ll address wheels versus eggs in another post in this blog series.) You try to conda install something, but you get the dreaded “Found conflicts! Looking for incompatible packages. This can take several minutes.” message. (If you’ve never given a lot of thought to the pragmatic ramifications of time complexity in search algorithms, this will absolutely drive it home for you.) You curse a lot while you wipe your installation and restore Anaconda from a backup. You install a package into your base environment and break it entirely, due to dependency conflicts. You waste a day reinstalling Python and your data science development environment. These are true stories. Fine, I’m convinced. How do you set up virtual environments? You can set up venvs in myriad different ways. I’ve spent a lot of time settling on a method that works for me. I wanted a system that was: Clean Flexible As automatic as possible Resistant to user error Inactive development Likely to continue to have robust support Caveats: I am using macOS Mojave on a MacBook Pro, with zsh. Most of these instructions will hold for other Unix-like systems, but they won’t all work on Windows. On Mac, Catalina has replaced bash with zsh, but beware that this tutorial is not tested on the newest version of macOS. Your experience will probably vary, but you’ll certainly learn something along the way. But first: Consider backups In addition to using version control, you should really consider backing up your files in the cloud. In the event something catastrophic happens, it’s a huge relief to be able to simply roll back to a previous snapshot of your hard drive. I use Arq Cloud Backup, which works similarly to git, and is pretty cheap and nearly automated. For Zotero, dotfiles, and smaller files I want more direct access to, I use Sync (essentially an end-to-end encrypted, GDPR-compliant Dropbox). Using pyenv with pyenv-virtualenv Again, there are lots of ways to install software, but I’ve found that managing packages with Homebrew, installing Python versions with pyenv, and handling venvs with pyenv-virtualenv gives me maximum flexibility with minimal pain. So how do you do it? Step 0: Clean up your Superfund Site First, the painful part: Nuking your old installation. Sorry. It has to be done. happy st. patrick’s day Before you touch anything, though, make sure you do not delete your system Python. If you’re on a Mac, that’s the Python 2.7 your computer needs to live. Delete that, and you’re cutting its brain stem. Don’t touch the Python files that sit in your usr/bin and /System/Library/Frameworks/Python.framework files. Let’s repeat: Don’t touch the system Python files. The Python you have installed will have to go, though. So if you installed it via a binary installer from python.org, go ahead and remove the app. If you installed Python via Anaconda, you’ll have to install anaconda-clean (and enjoy the irony of installing more Anaconda to remove Anaconda) to remove the software: conda install anaconda-clean && anaconda-clean — yes This line will remove Anaconda and create a .anaconda-backup folder, usually in your home directory. You can stash that somewhere safe or delete it. Anaconda leaves behind some remnants that auto-installation won’t erase, so you’ll need to manually delete your .anaconda and .condarc folders, as well as your ~/anaconda3 folder (or anaconda2, depending on which version you have). Double-check that you’ve taken care of loose ends with a search like the following (yours may be lowercase): $ grep -iR “Anaconda3” ~ Step 1: Get to know your shell profile Last, check your .bashrc or .bash_profile (or your .zshrc, especially if you’ve upgraded your Mac recently) and remove the lines that were written there when once upon a time you ran conda activate. This file probably lives in your user root — where you end up if you execute cd without specifying a directory name. If you’re on a Mac and you don’t see any dotfiles, pressing ? + ? + . (command-shift-period) will show your hidden files. Your login shell profile will have a name like .bashrc or .zshrc. (We’ll talk about their details later.) When you open your this file, you’ll see something like this: Go ahead and delete it or comment it out with #, if you’re nervous. (In another post, we’ll talk about how to manage your dotfiles.) You may also see something in your PATH that looks like this: Excise the /anaconda3 part, making sure the rest of the PATH makes sense and is colon-delimited. You’ll need to restart your shell after you modify this file. Replace .zshrc with your config file’s name if it’s not the same. For the rest of this tutorial, I’ll talk about zsh, because that’s what I use. Step 2: Install pyenv with Homebrew I use Homebrew for package management on Mac, but I’ve been eyeing a move to Nix. Either way, you should be using a package manager! Homebrew is essentially just Ruby and git, and does a good job of managing dependencies and keeping your applications organized and version-controlled. It also has a large and friendly community to ask for help. Different Linux distributions often have their own package managers built-in. Which package manager you choose is less important than the fact of actually using one. If you don’t already have Homebrew, bookmark this article. Go get Homebrew, install it, configure it, and then come back and follow these instructions. I’ll even put a bookmark here for you. Resume venv setup here (Welcome back!) With Homebrew, brew install python3. If you want to also install Python 2, you can brew install python2 or simply brew install python, both of which point to Homebrew’s Python 2 repositories, so be careful. Here’s the documentation. There are many traps for the unwary. Side note: We haven’t set up any venvs yet, but for future reference: when you brew install things that require Python, you should not be in a virtual environment. Before the next step, make sure the Python 3.x you just installed is the active one. Then: Pyenv is a tool that allows you to have multiple python installations side by side, even multiple versions of Anaconda! They’ll all live in their own separate environments, and you won’t have to worry about pip and conda conflicts. Step 3: Configure pyenv and pyenv-virtualenv Next, you need to set your PATH variable. The PATH variable is just a colon-delimited list of directories that the operating system searches in order from left to right. When you execute a command like python or pip, your OS wanders down your PATH, looking for directories with that name. Interlude: A primer on PATH and profiles Let’s take a quick break to explain why we are about to do what we’re about to do. Remember your .zshrc file? When you open a new login shell —that is, a session to interface with your computer from the command line — this file’s contents tell it how to behave for that session. (The “rc” in .zshrc stands for “run commands”.) That’s why PATH is defined in your shell profile. Pyenv is the switchboard operator for your operating system. Harriot Daley, chief telephone operator at the US Capitol (1937-07-30) When you source your .zshrc, you get the PATH that’s stored there. Pyenv inserts a directory of shims at the very beginning of the PATH: The shim directory is the switchboard. Pyenv maintains shims that correspond to every Python command across every installed version of Python on your system. Shims are the switchboard operators. They’re lightweight scripts that take the calls you make (Python commands) and connect them to the right recipient (the corresponding executable in pyenv). So, when you execute conda install keras, pyenv will: 0. Decide which Python version to use 1. Search your PATH for an executable with a name that matches conda 2. Find the pyenv shim named conda in $(pyenv root)/shims 3. Run the shim named conda, which redirects conda install keras to pyenv There’s also a pyenv Python path! In pyenv, the order of precedence is: 0. The PYENV_VERSION variable (which you can set with pyenv shell) 1. The directory’s .python_version file (which we can change with pyenv shell for a one-time change, or pyenv local for something more permanent) 2. The first .python_version file it can find, recursively searching each parent directory until it reaches root 3. The global $(pyenv root)/version file, which you can modify with pyenv global. Back to setup Now that you understand what you’re doing, here’s how to do it: Define the root directory for pyenv as .pyenv with the following code. (The official pyenv documentation has you write the following variables to a .zshenv file, but .zshrc works as well and is equivalent in most cases.) The variable $HOME is your user root. Note: Make sure you use >> and not >, or you will overwrite your file instead of concatenating. $ echo ‘ export PYENV_ROOT= “$HOME/.pyenv”’ >> ~/.zshrc; echo ‘export PATH=$PYENV_ROOT/bin:$PATH”’ >> ~/.zshrc Enable your shims (the switchboard operators) to manipulate the PATH: $ echo ‘eval $(pyenv init -) >> ~/.zshrc Step 4: Install pyenv-virtualenv Pyenv-virtualenv is a pyenv plugin that makes it a lot easier to manage venvs and conda environments. Configure virtualenv-init if you want to automatically activate and deactivate virtual environments on entering and leaving directories that contain a .python-version file: Make sure that this line comes after the one you added for pyenv. Python version files are created by executing pyenv local, or by manually creating the file and putting the name of a valid pyenv environment in it. Step 5: Download Python versions You can see which versions of Python are available for download by executing pyenv install --list. Install whichever you like, or more than one, with pyenv install. (You can always remove things with pyenv uninstall.) Make sure to set your global python with pyenv global \d.\d.\d, replacing \d with the appropriate digits. You can set a one-time version for the shell you’re currently working in with pyenv shell. Next, we’ll learn how to set the Python for each individual project with pyenv local and the .python-version file. Step 6: Make virtual environments! You should have a directory for every project, and a virtual environment for every directory. This structure does two important things: It keeps your stuff organized appropriately, which makes it easier to keep projects separate, manage dependencies, and keep out things that shouldn’t be there. (Who likes having to undo git commits?) It lets you create a separate .python-version file for each directory (and therefore for each project), which means pyenv-virtualenv can automatically switch to the appropriate environment for you when you change directories. Make a project folder and cd into it. Set your project Python with pyenv local $PYTHON_VERSION. Check that you’re using the one you wanted (the output should show which Python interpreter the shell is using and how it was set). Now the fun part. You’re going to make a virtual environment. Unlike the manually-managed venvs, pyenv-virtualenv consolidates all your virtual environments in one directory, rather than scattering them throughout your project files. This is really nice, but it means you can’t just name all of them venv. A good mnemonic is to give them the same name as your project, so you remember which things go together. Personal preference: I name my environments venv-$PROJECT_NAME. That makes them easy to organize and helps maintain compatibility with older .gitignore files that generally assume venv is the name of your virtual environment. Run this command to make a virtual environment: If you leave out the Python version, your environment will use the one that is currently in effect locally. Step 7: Activate your virtual environment To activate your new environment and set it as the project’s local Python, you’ll need to execute: $ pyenv local venv-cool_project && pyenv activate venv-cool_project or $ conda activate venv-cool_project depending on whether you chose an Anaconda distribution for your base Python. (You can also use $ source activate for the venv module.) Step 8: Whatever you want You did it! If you run the one-liner below every time you create a new project, you should be able to cd in and out of directories and have your virtual environments automatically activate and deactivate. (Of course, you’ll need to change the environment name and Python interpreter.) $ mkdir $2 && cd $2 && pyenv local $1 && pyenv virtualenv venv-$2 && pyenv local venv-$2 && pyenv activate venv-$2 Here’s a GitHub gist with a script that will do it for you. Download it (you may need to run chmod +x newproj.sh to make sure it’s executable). Then just use it to create new projects by passing it the python version you want to use and the name of your project: now you really have no excuse not to use venvs. As a reward for the hard work, hop over to my next blog to see all the really cool tricks Visual Studio Code can do now (like automatically selecting the right virtual interpreter for your project directory ? ?). In a future post, we’ll go over the easiest way to populate your environments with the packages you need from a requirements.txt or an environment file, as well as using Docker, Binder, RStudio Cloud, and other containers or cloud-based IDEs when you don’t need a dedicated virtual environment. Develop to your heart’s content. HELP!! I forgot the commands. One of the reasons I prefer pyenv is because it’s so well-documented, and help is easy to get without leaving the command line. The algorithm for getting unstuck is: execute pyenv commands choose a command from the list execute pyenv $COMMAND_NAME --help read the usage notes and examples This method will solve a lot of your immediate problems. Where is all my pyenv stuff? If you set things up right, all your pyenv files, including all the virtual environments and Python versions that pyenv-virtualenv creates, should be in $HOME/.pyenv. If they’re not, check your configuration! (We’ll cover symlinks, Homebrew, and file organization in more detail in another post.) You probably named something differently, used a different package manager, created directories somewhere other than root, or didn’t start off with a clean slate (something else was jamming your PATH). My virtual environments show up in my project folder/they’re not where I thought they would be/they’re not working. You probably created your environment with virtualenv instead of pyenv virtualenv. Yes, they’re different. Yes, it’s annoying. I recommend adding an alias to your .zshrc to stop yourself from doing this. If you’re having trouble executing any of the pyenv commands, double check that you added the init statements to your .zshrc in the right order. When in doubt, printenv, which python, and echo $PATH are good diagnostics for checking your environment variables, which Python you’re using, and what’s in your path at any given time. Tell me how to uninstall all this stuff you made me do. I hate tutorials that don’t tell you how to get rid of things. To see all the venvs and Pythons you’ve created, execute pyenv versions. To remove any of them you don’t need anymore, you can just delete the directory, or you can pyenv uninstall $VERSION_OR_VENV. I recommend making a record of the environment with pip freeze > requirements.txt or conda env export > environment.yml, though, so you can recreate it if you need to. If you want to get rid of everything,rm -rf .pyenv is enough. You can also brew uninstall both pyenv and pyenv-virtualenv if you prefer. This is the uninstall command for Homebrew: Thanks to pyenv, you can uninstall Python by deleting the files where your virtual environments are stored. Even the Anaconda distributions. No anaconda-clean required. Isn’t that satisfying? This is awesome. What else can I do? Stick around and learn about: Using the command line to streamline your setup and workflow Turning GitHub repos into virtual environments with repo2docker Temporary venvs, cloud-based IDEs like Binder and RStudio Cloud, Minikube Wheels and eggs, or why you shouldn’t mix pip and conda unless you’re really sure about what you’re doing Building a project ecosystem from a requirements file or environment spec, or vice versa Symlinks, Homebrew, and your OS’s file organization in more detail, if you’re still confused Making all of these components work cross-linguistically You know a lot more about your Python installation now. Managing your dependencies and practicing good version control will make your individual projects easier to manage; help you more easily create requirements files for your GitHub projects; allow you to clone environments and replicate your data projects; and improve your ability to prevent problems and—when they do happen — to identify their sources and solutions. is it worth the time? Setting up pyenv and pyenv-virtualenv takes an investment of patience and attention to detail upfront, but it pays off in knowledge gained, time saved, frustration avoided — not to mention software and science that are usable and reproducible. // thanks to Michael Carlisle for being the guinea pig who bit the python back. The Startup Medium's largest active publication, followed by +604K people. Follow to join our community. Follow 252 Python Programming Data Science Software Development Software Engineering 252 claps Written by Lora Johns Follow Machine learning, linguistics, NLP | { B.A. : Dartmouth, J.D. : Yale, M.S. : Simmons } Follow The Startup Follow Medium's largest active publication, followed by +604K people. Follow to join our community. Follow See responses (4) More From Medium More from The Startup More from The Startup My Friend Lost His Business After a 15-Minute Speech Tim Denning in The Startup Mar 24 · 5 min read 8.3K More from The Startup More from The Startup The science behind coronavirus testing, and where the U.S. went wrong Anna Minkina in The Startup Mar 19 · 10 min read 1.6K More from The Startup More from The Startup Flutter vs Native vs React-Native: Examining performance inVerita in The Startup Mar 10 · 4 min read 4.3K Discover MediumWelcome to a place where words matter. On Medium, smart voices and original ideas take center stage - with no ads in sight. Watch Make Medium yoursFollow all the topics you care about, and we’ll deliver the best stories for you to your homepage and inbox. Explore Become a memberGet unlimited access to the best stories on Medium — and support writers while you’re at it. Just $5/month. Upgrade AboutHelpLegal
